function [ CL, filter_meta ] = ChainPairs2( dL, radix, filters )
%ChainPairs v2 Synthesizes list of potential node groups by chaining
%connection pairs. At present only handles 2 topology systems.
%   Author: Edgar Pan (edgar.pan@mail.mcgill.ca)
%   Initially written: 2019-12-18
%     In essence, this program takes a list of potential link
%     reconfigurations and "chains" them into the two sides of a crosspoint
%     switch. It does this by first selecting a "Root" Index, determined by
%     the source node of a particular reconfiguration pair (dL).
%     Next, designating the Destination Node for Topology 2 as the "Tail",
%     it finds a dL pair with the "Head" or Destination Node for Topology 1
%     that matches the Tail of the previous dL. 
%   Input:
%       dL - Changes in Links list.
%           Formerly "Node Connection", 
%           most likely generated by GenConnList.m
%               Format: [SourceNode Topology1Node Topology2Node ...]
%       radix - determines the number of ports on a one side of a switch.
%       filters - Manually selects which filters to use. Default: All
%           active.
%               Format: [Stepback Overlap/Looping Equivalence]
%               crosspoint switch.
%               -Stepback - Prevents process from scanning through prior
%               columns/rows.
%               -Overlap/Looping - Scans for contributed Link redundancies
%               -Equivalence - Scans for GPs that are equivalent
%   Output:
%       CL - "Chain List"
%           Cell Array
%           {1} = Completed GroupPair List
%           {2} = Minimum Chain List
%           {3} = Split Chain-Composite List
%               {1} Chains that are perfect fit for given Radix size.
%               {2} Composite Blocks composed of Minimum Chain List
%           {4} = Incomplete Chain List
%       filter_meta - Metadata generated by the process filters.
%           {1} = Record Metadata. If no variable records the metadata in
%           output, then metadata will not even be processed. Will be
%           equals to [1] if filter_meta exists as an output variable.
%           {2} = Metadata for Stepback Filter
%               Rows correspond to the completed Root_Index node.
%               Column 1 corresponds to the number of completed chains
%                   compiled so far.
%               Column 2 corresponds to a list of Delta Links at end of
%                   corresponding Root_Index.
%           {3} = Metadata for Equivalence Filter
%               {1} list - full unfiltered list
%               {2} ia - Index kept from original list. 
%                       i.e. filtered_list = list(:,:,ia).
%               {3} ic - Index to recreate original list. 
%                       i.e. list = filtered_list(:,:,ic)
%              	{4} filtered_index - List of indices that has been removed.

    %%Initialization
    %Current iteration of acceptable Delta Links
    dL_List = dL;
    
    %Number of vertices in the graph (Order). Used to set Loop Limit
    Graph_Order = max(max(dL));
    
    %Initializes Connection Chain as empty sets.
    CL = cell(4,1);
    
    %%Filters
    %Development constant: How many filters were implemented
    Filters_Constant = 3;
    
    %Activation of Composite Group Pair generation (manual activation)
    CompGPActive = true;
    
    %initialize the filters' meta data
    if nargout < 2
        filter_meta = {0};
    else
        filter_meta = {1, cell(Graph_Order,2) ,[]};
    end
    
    if nargin < 3 || length(filters) ~= Filters_Constant
        use_filters = ones(1,Filters_Constant);
        disp('ChainPairs2.m: Default Filter used')
    else
        use_filters = filters;
    end
    
    %%
    %Scans through Node Connection List
    for j = 1:Graph_Order
        %Generate Potential Root List (Starting Points)
        Root_Index = dL_List(:,1)==j; %Creates logic array
        Root_List = dL_List(Root_Index,:); %Which then this scans faster
        Root_Length = size(Root_List(:,1),1);
        
        %Cycle through Root List
        for i = 1:Root_Length
            %Creates a template with the Chain's current Progress
            ChainProgress = Root_List(i,:);
            %Feeds the Chain template into the recursive system.
            [CL,filter_meta] = ChainNext2(dL_List,radix,...
                CL,ChainProgress,...
                use_filters,filter_meta);
        end
        
        %%
        %Stepback Filter
        if use_filters(1)
            %Filter Meta Data
            %Saves the removed value in the debug output
            if filter_meta{1}
                %Saves length of potential GP list at end of 
                %each Root_Index.
                %In other words, "when" the stepback has occurred.
                filter_meta{2}{j,1}=size(CL{1},3);
                
                %Saves removed value into metadata
                if isempty(filter_meta{2}{j,2})
                    filter_meta{2}{j,2} = dL_List(any(dL_List==j,2),:);
                else
                    filter_meta{2}{j,2} = ...
                        cat(1, filter_meta{2}{j,2},...
                        dL_List(any(dL_List==j,2),:));
                end
            end
            
            dL_List = dL_List(~any(dL_List==j,2),:);
            %Finds every instance of the first column and the first row
            %And removes them from the list
        end
    end
    
    %%
    %Reorganize CL{1}
    CmpltChains = CL{1};
    
    
    %%
    %Create Composite GroupPairs
    if CompGPActive && ~isempty(CL{2})
        Comp = CreateCompGP(CL{2},radix,filters);
        CompMat = cell2mat(reshape(Comp,1,1,[]));
        FullList = cat(3,CmpltChains,CompMat);
    else
        FullList = CmpltChains;
    end
    
    %%
    postprocequivfil = filters(3);
    
    %Post-Processing Equivalence Filter
    if postprocequivfil
        %Finds the amount of possible group pairs and creates a cell array for
        %it. Also creates a reordered version of the list.
        list = FullList;
        sizeList = size(list,3);
        
        %Limit of when Chains end and Composite Groups start
        sizeSplit = size(CmpltChains,3);


        %Method: Take every group pair pages, line it up into a single row.
        %Then reorder it from smallest to largest. Then find any duplicates
        %with unique().

        sortedList = sort(reshape(list,[],sizeList))';
            %In this case, lists out all Group Pairs in an array of
            %columns. Then transposes the list so that each ROWS represents
            %a group pair

        [~, ia, ic] = unique(sortedList,'rows','stable');
        
        %insert filter metadata
        filter_meta{3}{1} = list;
        filter_meta{3}{2} = ia;
        filter_meta{3}{3} = ic;
        filter_meta{3}{4} = setdiff(1:sizeList,ia); %What was removed

        %Uses the index for unique values returned from uniqueness scan
        %To select which group pairs to keep.
        FullList = list(:,:,ia);
        CmpltChains = list(:,:,ia(ia<=sizeSplit));
        CompMat = list(:,:,ia(ia>sizeSplit));
    end
    CL{1} = FullList;
    CL{3} = {};
    CL{3}{1} = CmpltChains;
    CL{3}{2} = CompMat;
end